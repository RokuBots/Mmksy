import os
import re
import base64
import requests
from urllib.parse import urlparse, parse_qs
import time
import cloudscraper
from bs4 import BeautifulSoup

from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram import filters
import PyBypass as bypasser

from ..config import Config



GDTOT_CRYPT = 'b0lDek5LSCt6ZjVRR2EwZnY4T1EvVndqeDRtbCtTWmMwcGNuKy8wYWpDaz0%3D'


async def parse_info(res):
    title = re.findall(">(.*?)<\/h5>", res.text)[0]
    info = re.findall('<td\salign="right">(.*?)<\/td>', res.text)
    parsed_info = {
        'error': True,
        'message': 'Link Invalid.',
        'title': title,
        'size': info[0],
        'date': info[1]
    }
    return parsed_info

#################################################################
async def bypass(url: str):
    client = cloudscraper.create_scraper(allow_brotli=False)
    p = urlparse(url)
    final_url = f'{p.scheme}://{p.netloc}/links/go'

    res = client.head(url)
    header_loc = res.headers['location']
    param = header_loc.split('postid=')[-1]
    req_url = f'{p.scheme}://{p.netloc}/{param}'

    p = urlparse(header_loc)
    ref_url = f'{p.scheme}://{p.netloc}/'

    h = { 'referer': ref_url }
    res = client.get(req_url, headers=h, allow_redirects=False)

    bs4 = BeautifulSoup(res.content, 'html.parser')
    inputs = bs4.find_all('input')
    data = { input.get('name'): input.get('value') for input in inputs }

    h = {
        'referer': ref_url,
        'x-requested-with': 'XMLHttpRequest',
    }
    time.sleep(1)
    res = client.post(final_url, headers=h, data=data)
    try:
        return res.json()['url'].replace('\/','/')
    except: return 'Something went wrong :('

def droplink_bypass(url):
    client = requests.Session()
    res = client.get(url)

    ref = re.findall("action[ ]{0,}=[ ]{0,}['|\"](.*?)['|\"]", res.text)[0]

    h = {'referer': ref}
    res = client.get(url, headers=h)

    bs4 = BeautifulSoup(res.content, 'lxml')
    inputs = bs4.find_all('input')
    data = { input.get('name'): input.get('value') for input in inputs }

    h = {
        'content-type': 'application/x-www-form-urlencoded',
        'x-requested-with': 'XMLHttpRequest'
    }
    p = urlparse(url)
    final_url = f'{p.scheme}://{p.netloc}/links/go'

    time.sleep(2.1)
    res = client.post(final_url, data=data, headers=h).json()
    return res["url"]


# Mdisk
async def mdis_k(urlx):
    scraper = cloudscraper.create_scraper(interpreter="nodejs", allow_brotli=False)
    headers = {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36"
    }
    apix = f"http://x.egraph.workers.dev/?param={urlx}"
    response = scraper.get(apix, headers=headers)
    query = response.json()
    return query


async def mdisk(url):
    check = re.findall(r"\bhttps?://.*mdisk\S+", url)
    if not check:
        textx = f"**Invalid Mdisk Url**"
        return textx
    else:
        try:
            fxl = url.split("/")
            urlx = fxl[-1]
            uhh = await mdis_k(urlx)
            duration = {uhh["duration"]}
            text = f'**üìÇ Title** : `{uhh["filename"]}`\n\nüì• **Download URL (Support All Player)** :- {uhh["source"]}\n\nüì§ **Download URL (Support Only MX Player)** :- {uhh["download"]}\n\nüíé **Uploader User ID** :- `{uhh["from"]}`\n\nüí† **Uploader User Name** :- `@{uhh["display_name"]}`\n\nüìπ **Video Width** :- `{uhh["width"]}`\n\nüéû **Video Height** :- {uhh["height"]}\n\nüì¶ **Video Duration** :- `{uhh["duration"]}s`\n\nüìä **Video Size** :- `{uhh["size"]}kb`'
            return text
        except ValueError:
            textx = f"The Content is Deleted."
            return textx

# gdtot
async def gdtot(url: str) -> str:
    if GDTOT_CRYPT is None:
        return "GdTot Crypt not provided"
    crypt = GDTOT_CRYPT
    client = requests.Session()
    match = re.findall(r"https?://(.+)\.gdtot\.(.+)\/\S+\/\S+", url)[0]
    client.cookies.update({"crypt": crypt})
    res = client.get(url)
    res = client.get(f"https://{match[0]}.gdtot.{match[1]}/dld?id={url.split('/')[-1]}")
    url = re.findall(r'URL=(.*?)"', res.text)[0]
    info = {}
    info["error"] = False
    params = parse_qs(urlparse(url).query)
    if "gd" not in params or not params["gd"] or params["gd"][0] == "false":
        info["error"] = True
        if "msgx" in params:
            info["message"] = params["msgx"][0]
        else:
            info["message"] = "Invalid link"
    else:
        decoded_id = base64.b64decode(str(params["gd"][0])).decode("utf-8")
        drive_link = f"https://drive.google.com/open?id={decoded_id}"
        info["gdrive_link"] = drive_link
    if not info["error"]:
        return info["gdrive_link"]
    else:
        return f"{info['message']}"

##################################################################

@Client.on_message(filters.command('mdisk'))
async def link_handler(bot, message):
    ""sending Link To DB CHANNEL"""
    if Config.DB_CHANNEL_ID:
        try:
            log_message = await m.forward(Config.DB_CHANNEL_ID)
            m = "Message Sender Information\n"
            m += "\nFirst Name: " + message.from_user.first_name
            m += "\nUser ID: " + str(message.from_user.id)
            m += "\nUsername: @" + message.from_user.username if message.from_user.username else ""
            m += "\nUser Link: " + message.from_user.mention
            m += "\nMessage: " + message.text

            await log_message.reply_text(
                text=m,
                disable_web_page_preview=True,
                quote=True
            )
        except Exception as error:
            print(error)
 # link = message.matches[0].group(0)
  l = message.text.split(' ', 1)

  if len(l) == 1:
        return await message.reply_text('Send Me Any Mdisk Link Like this `/mdisk mdisk-link`')
  link = l[1]
  #mess = await message.reply_text("**Bypassing...‚è≥**",quote=True)

  if 'mdisk' in link:
     try:
        mess = await message.reply_text("**Bypassing...‚è≥**",quote=True)
        short_link = await mdisk(link)
        await mess.edit_text(f"{short_link} \n\n ¬© {message.from_user.mention}", disable_web_page_preview=True)
     except Exception as e:
        await mess.edit_text(f"**Error** : {e}")

# gdtot url
@Client.on_message(filters.command('gdtot'))
async def gt(bot, message):
    ""sending Link To DB CHANNEL"""
    if Config.DB_CHANNEL_ID:
        try:
            log_message = await m.forward(Config.DB_CHANNEL_ID)
            m = "Message Sender Information\n"
            m += "\nFirst Name: " + message.from_user.first_name
            m += "\nUser ID: " + str(message.from_user.id)
            m += "\nUsername: @" + message.from_user.username if message.from_user.username else ""
            m += "\nUser Link: " + message.from_user.mention
            m += "\nMessage: " + message.text

            await log_message.reply_text(
                text=m,
                disable_web_page_preview=True,
                quote=True
            )
        except Exception as error:
            print(error)
 # link = message.matches[0].group(0)
  l = message.text.split(' ', 1)

  if len(l) == 1:
        return await message.reply_text('Send Me Any Gdtot Link Like this `/gdtot gdtot-link`')
  url = l[1]
  #mess = await message.reply_text("**Bypassing...‚è≥**",quote=True)

  if 'gdtot' in url:
     try:
        mess = await message.reply_text("**Bypassing...‚è≥**",quote=True)
        short_link = await gdtot(url)
        await mess.edit_text(f"**Bypassed URL** : {short_link} \n\n ¬© {message.from_user.mention}", disable_web_page_preview=True)
     except Exception as e:
        await mess.edit_text(f"**Error** : {e}")



